
}

size_t typeNameLength(comptime tgpe T) {
    return @typeName(T).len;
}

u32 numbers_left;

u32!anyerror eventuallyErrorSequence() {
    return if (numbers_left == 0) error.ReachedZero else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}
```

 
**Zig**
```
const expect = @import("std").testing.expect;

test "inline while loop" {
    comptime var i = 0;
    var sum: usize = 0;
    inline while (i < 3) : (i += 1) {
        const T = switch (i) {
            0 => f32,
            1 => i8,
            2 => bool,
            else => unreachable,
        };
        sum += typeNameLength(T);
    }
    try expect(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}

var numbers_left: u32 = undefined;

fn eventuallyErrorSequence() anyerror!u32 {
    return if (numbers_left == 0) error.ReachedZero else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}
```
  
**ZigC**
```
from std.testing import expect;

test "for basics" {
    const items = int[]{ 4, 5, 3, 4, 0 };
    int sum = 0;

    for value in items {
        if (value == 0) {
            continue;
        }
        sum += value;
    }
    try expect(sum == 16);

    for value in items[0..1] {
        sum += value;
    }
    try expect(sum == 20);

    int sum2 = 0;
    for i, _ in items {
        try expect(@TypeOf(i) == size_t); // size_t ?? alias usize
        sum2 += @intCast(int, i);
    }
    try expect(sum2 == 10);
}

test "for reference" {
    int[] items = { 3, 4, 2 };

    for *value in items {
        *value += 1;
    }

    try expect(items[0] == 4);
    try expect(items[1] == 5);
    try expect(items[2] == 3);
}

test "for else" {
    int?[] items = { 3, 4, null, 5 };

    int sum = 0;
    const result = for value in items {
        if (value != null) {
            sum += value; // ?? '?' needed
        }
    } else blk: {
        try expect(sum == 12);
        break :blk sum;
    };
    try expect(result == 12);
}
```


**Zig**
```
const expect = @import("std").testing.expect;

test "for basics" {
    const items = [_]i32 { 4, 5, 3, 4, 0 };
    var sum: i32 = 0;

    for (items) |value| {
        if (value == 0) {
            continue;
        }
        sum += value;
    }
    try expect(sum == 16);

    for (items[0..1]) |value| {
        sum += value;
    }
    try expect(sum == 20);

    var sum2: i32 = 0;
    for (items) |_, i| {
        try expect(@TypeOf(i) == usize);
        sum2 += @intCast(i32, i);
    }
    try expect(sum2 == 10);
}

test "for reference" {
    var items = [_]i32 { 3, 4, 2 };

    for (items) |*value| {
        value.* += 1;
    }

    try expect(items[0] == 4);
    try expect(items[1] == 5);
    try expect(items[2] =
  
## labled for
  
**ZigC**
```
from std.testing import expect;

test "nested break" {
    size_t count = 0;
    outer: for _ in int[]{ 1, 2, 3, 4, 5 } {
        for _ in int[]{ 1, 2, 3, 4, 5  f32,
            4 => i8,
            6 => bool,
            else => unreachable,
        };
        sum += typeNameLength(T);
    }
    try expect(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}
```
   



